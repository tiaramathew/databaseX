import { NextResponse } from "next/server";
import { mockDbClient } from "@/lib/db/client";
import { logger } from "@/lib/logger";
import type { SearchResult } from "@/lib/db/adapters/base";

interface RAGRequest {
    query: string;
    collection?: string;
    topK?: number;
    minScore?: number;
    agent?: {
        type: "mcp" | "webhook" | "mock";
        endpoint?: string;
        name?: string;
        config?: {
            type?: "stdio" | "sse";
            command?: string;
            args?: string[];
            url?: string;
            baseUrl?: string;
        };
    };
}

interface RAGResponse {
    response: string;
    context: SearchResult[];
    agentUsed: string;
}

// Generate a helpful response based on query and context
function generateResponse(query: string, context: SearchResult[], agentName?: string): string {
    if (context.length === 0) {
        return `I searched the vector database for information about "${query}" but didn't find any matching documents.

**Suggestions:**
- Try uploading documents related to your query
- Rephrase your question with different keywords
- Lower the minimum similarity score in the settings

${agentName ? `\n*Response generated by: ${agentName}*` : ""}`;
    }

    const contextSummary = context
        .slice(0, 3)
        .map((c, i) => {
            const source = (c.metadata?.source as string) || `Document ${i + 1}`;
            const preview = c.content?.slice(0, 300) || "No content available";
            return `**[${i + 1}] ${source}** (${(c.score * 100).toFixed(0)}% match)\n${preview}${c.content && c.content.length > 300 ? "..." : ""}`;
        })
        .join("\n\n");

    return `Based on ${context.length} relevant document(s) found in your vector database:

${contextSummary}

---
*Retrieved ${context.length} documents with similarity scores from ${(context[context.length - 1]?.score * 100).toFixed(0)}% to ${(context[0]?.score * 100).toFixed(0)}%*
${agentName ? `*Response via: ${agentName}*` : ""}`;
}

// Call webhook agent (Make.com, n8n, Zapier, etc.)
async function callWebhookAgent(
    endpoint: string,
    query: string,
    context: SearchResult[],
    agentName: string
): Promise<string> {
    try {
        logger.info(`Calling webhook agent: ${agentName} at ${endpoint}`);
        
        const response = await fetch(endpoint, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                query,
                message: query,
                context: context.map((c) => ({
                    content: c.content,
                    score: c.score,
                    metadata: c.metadata,
                    source: c.metadata?.source,
                })),
                timestamp: new Date().toISOString(),
            }),
        });

        if (!response.ok) {
            const errorText = await response.text().catch(() => "Unknown error");
            throw new Error(`Webhook returned ${response.status}: ${errorText}`);
        }

        const data = await response.json();
        
        // Handle various response formats from automation platforms
        const result = data.response || data.message || data.content || data.text || data.output || data.result;
        
        if (typeof result === "string") {
            return result;
        } else if (result) {
            return JSON.stringify(result, null, 2);
        }
        
        return JSON.stringify(data, null, 2);
    } catch (error) {
        logger.error("Webhook agent call failed", error instanceof Error ? error : undefined);
        throw error;
    }
}

// Call MCP agent (stdio or SSE)
async function callMcpAgent(
    endpoint: string | undefined,
    query: string,
    context: SearchResult[],
    agentName: string,
    config?: RAGRequest["agent"]["config"]
): Promise<string> {
    try {
        logger.info(`Calling MCP agent: ${agentName}`);
        
        // For SSE-based MCP servers
        if (config?.type === "sse" && config.url) {
            const response = await fetch(config.url, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                },
                body: JSON.stringify({
                    jsonrpc: "2.0",
                    id: Date.now(),
                    method: "tools/call",
                    params: {
                        name: "query",
                        arguments: {
                            query,
                            context: context.map((c) => ({
                                content: c.content,
                                relevance: c.score,
                                source: c.metadata?.source,
                            })),
                        },
                    },
                }),
            });

            if (!response.ok) {
                throw new Error(`MCP endpoint returned ${response.status}`);
            }

            const data = await response.json();
            return data.result?.content || data.response || JSON.stringify(data);
        }
        
        // For stdio-based MCP servers (command-based)
        // These run as local processes - we simulate a response here
        // In production, you'd use a proper MCP client library
        if (config?.type === "stdio" && config.command) {
            // Since we can't easily spawn processes in Next.js API routes,
            // we'll return the context in a formatted way
            const contextText = context
                .map((c) => `Source: ${c.metadata?.source || "Unknown"}\n${c.content}`)
                .join("\n\n---\n\n");
            
            return `**Query:** ${query}

**Retrieved Context from Vector Database:**

${contextText || "No relevant documents found."}

---
*Note: This MCP server (${agentName}) uses stdio transport. For full AI-powered responses, use an HTTP/SSE-based endpoint or configure a webhook to an AI service.*`;
        }

        // Fallback for HTTP endpoint
        if (endpoint) {
            const response = await fetch(endpoint, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({
                    query,
                    context: context.map((c) => ({
                        content: c.content,
                        score: c.score,
                        metadata: c.metadata,
                    })),
                }),
            });

            if (!response.ok) {
                throw new Error(`MCP endpoint returned ${response.status}`);
            }

            const data = await response.json();
            return data.result?.content || data.response || data.message || JSON.stringify(data);
        }

        throw new Error("No valid MCP endpoint configured");
    } catch (error) {
        logger.error("MCP agent call failed", error instanceof Error ? error : undefined);
        throw error;
    }
}

export async function POST(request: Request) {
    try {
        const body: RAGRequest = await request.json();
        const { query, collection, topK = 5, minScore = 0.5, agent } = body;

        if (!query) {
            return NextResponse.json(
                {
                    code: "VALIDATION_ERROR",
                    message: "Query is required",
                },
                { status: 400 }
            );
        }

        // Step 1: Retrieve relevant context from vector database (if collection specified)
        let context: SearchResult[] = [];
        
        if (collection) {
            try {
                context = await mockDbClient.search(collection, {
                    text: query,
                    topK,
                    minScore,
                    includeContent: true,
                    includeMetadata: true,
                });
                logger.info(`Retrieved ${context.length} documents from collection "${collection}"`);
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : "Unknown error";
                logger.warn(`Collection search failed: ${errorMessage}`);
                // Continue without context rather than failing
            }
        }

        // Step 2: Generate response based on agent type
        let response: string;
        let agentUsed: string;
        const agentName = agent?.name || "Vector Search";

        if (!agent || agent.type === "mock") {
            // Use built-in response generator
            response = generateResponse(query, context, "Vector Search");
            agentUsed = "Vector Search";
        } else if (agent.type === "webhook") {
            // Call webhook agent (Make.com, n8n, Zapier, etc.)
            const endpoint = agent.endpoint || agent.config?.baseUrl;
            if (endpoint) {
                try {
                    response = await callWebhookAgent(endpoint, query, context, agentName);
                    agentUsed = agentName;
                } catch (err) {
                    const errorMsg = err instanceof Error ? err.message : "Unknown error";
                    logger.error(`Webhook call failed: ${errorMsg}`);
                    response = generateResponse(query, context, agentName);
                    response += `\n\n⚠️ *Could not reach webhook endpoint. Showing vector search results instead.*\n*Error: ${errorMsg}*`;
                    agentUsed = `${agentName} (fallback)`;
                }
            } else {
                response = generateResponse(query, context, agentName);
                response += "\n\n⚠️ *No webhook endpoint configured.*";
                agentUsed = "Vector Search";
            }
        } else if (agent.type === "mcp") {
            // Call MCP agent
            try {
                response = await callMcpAgent(
                    agent.endpoint,
                    query,
                    context,
                    agentName,
                    agent.config
                );
                agentUsed = agentName;
            } catch (err) {
                const errorMsg = err instanceof Error ? err.message : "Unknown error";
                logger.error(`MCP call failed: ${errorMsg}`);
                response = generateResponse(query, context, agentName);
                response += `\n\n⚠️ *Could not communicate with MCP server. Showing vector search results instead.*`;
                agentUsed = `${agentName} (fallback)`;
            }
        } else {
            response = generateResponse(query, context, "Vector Search");
            agentUsed = "Vector Search";
        }

        const result: RAGResponse = {
            response,
            context,
            agentUsed,
        };

        return NextResponse.json(result);
    } catch (error) {
        logger.error("POST /api/rag failed", error instanceof Error ? error : undefined);
        return NextResponse.json(
            {
                code: "INTERNAL_ERROR",
                message: error instanceof Error ? error.message : "Failed to process RAG request",
            },
            { status: 500 }
        );
    }
}

